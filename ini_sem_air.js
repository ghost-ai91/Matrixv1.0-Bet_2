// inicializacao.js - Vers√£o para contrato SEM MINT e COM SWAP
const {
  Connection,
  Keypair,
  PublicKey,
  SystemProgram,
} = require("@solana/web3.js")
const { AnchorProvider, Program } = require("@coral-xyz/anchor")
const fs = require("fs")
const path = require("path")

// Receber par√¢metros da linha de comando
const args = process.argv.slice(2)
const walletPath = args[0] || "/Users/dark/.config/solana/id.json"
const configOutputPath = args[1] || "./matriz-config.json"

// Carregue seu IDL compilado
const idl = require("./target/idl/referral_system.json")

// Configura√ß√µes principais - ATUALIZADO para contrato sem mint
const PROGRAM_ID = new PublicKey(
  "G6dU3Ghhg7YGkSttucjvRzErkMAgPhFHx3efZ65Embin"
)
const MULTISIG_TREASURY = new PublicKey(
  "5C16cVYXe7KRPz6rBD33qhcqyjvy42LP8tyJRNMXbKiL"
)

// Fun√ß√£o para carregar uma carteira a partir de um arquivo
function loadWalletFromFile(filePath) {
  if (!fs.existsSync(filePath)) {
    throw new Error(`Arquivo de carteira n√£o encontrado: ${filePath}`)
  }
  return Keypair.fromSecretKey(
    Uint8Array.from(JSON.parse(fs.readFileSync(filePath, "utf-8")))
  )
}

async function main() {
  try {
    console.log(
      "üöÄ INICIALIZANDO PROGRAMA DE MATRIZ (SEM MINT - COM SWAP) üöÄ"
    )
    console.log(
      "================================================================="
    )
    console.log(`Usando arquivo de carteira: ${walletPath}`)
    console.log(`Multisig Treasury: ${MULTISIG_TREASURY.toString()}`)
    console.log("üîÑ Vers√£o: Swap Only (Sem sistema de mint)")

    // Conectar √† devnet
    const connection = new Connection(
      "https://weathered-quiet-theorem.solana-devnet.quiknode.pro/198997b67cb51804baeb34ed2257274aa2b2d8c0",
      "confirmed"
    )
    console.log("Conectando √† Devnet")

    // Carregar carteira
    let walletKeypair
    try {
      walletKeypair = loadWalletFromFile(walletPath)
      console.log(
        "üë§ Endere√ßo da carteira: " +
          walletKeypair.publicKey.toString()
      )
    } catch (e) {
      console.error(`‚ùå Erro ao carregar carteira: ${e.message}`)
      return
    }

    // Verificar saldo da carteira
    const balance = await connection.getBalance(
      walletKeypair.publicKey
    )
    console.log(`üí∞ Saldo: ${balance / 1_000_000_000} SOL`)

    if (balance < 1_000_000_000) {
      console.warn(
        "‚ö†Ô∏è Saldo baixo! Recomendamos pelo menos 1 SOL para a inicializa√ß√£o."
      )
      return
    }

    // Configurar o provider com a carteira
    const provider = new AnchorProvider(
      connection,
      {
        publicKey: walletKeypair.publicKey,
        signTransaction: async (tx) => {
          tx.partialSign(walletKeypair)
          return tx
        },
        signAllTransactions: async (txs) => {
          return txs.map((tx) => {
            tx.partialSign(walletKeypair)
            return tx
          })
        },
      },
      { commitment: "confirmed" }
    )

    // Inicializar o programa
    const program = new Program(idl, PROGRAM_ID, provider)

    // Gerar um novo keypair para o estado
    const stateKeypair = Keypair.generate()
    console.log(
      "üîë Novo endere√ßo de estado: " +
        stateKeypair.publicKey.toString()
    )

    // Inicializar o estado do programa
    console.log("\nüìù INICIALIZANDO ESTADO DO PROGRAMA (SEM MINT)...")

    try {
      const tx = await program.methods
        .initialize()
        .accounts({
          state: stateKeypair.publicKey,
          owner: walletKeypair.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([stateKeypair])
        .rpc()

      console.log("‚úÖ PROGRAMA INICIALIZADO COM SUCESSO: " + tx)
      console.log(
        `üîç Link para explorador: https://explorer.solana.com/tx/${tx}?cluster=devnet`
      )

      // Verificar informa√ß√µes do estado
      const stateInfo = await program.account.programState.fetch(
        stateKeypair.publicKey
      )
      console.log("\nüìä INFORMA√á√ïES DO ESTADO DA MATRIZ:")
      console.log("üëë Owner: " + stateInfo.owner.toString())
      console.log(
        "üè¶ Multisig Treasury: " +
          stateInfo.multisigTreasury.toString()
      )
      console.log(
        "üÜî Pr√≥ximo ID de upline: " +
          stateInfo.nextUplineId.toString()
      )
      console.log(
        "üÜî Pr√≥ximo ID de chain: " + stateInfo.nextChainId.toString()
      )

      // Verificar prote√ß√£o de reentrancy
      if (stateInfo.isLocked !== undefined) {
        console.log(
          "üõ°Ô∏è Prote√ß√£o Reentrancy: " + (stateInfo.isLocked ? "ATIVADA" : "PRONTA")
        )
        if (stateInfo.isLocked) {
          console.log("‚ö†Ô∏è AVISO: Estado inicializado com lock ativo - isso n√£o deveria acontecer!")
        } else {
          console.log("‚úÖ Estado inicializado corretamente sem lock")
        }
      } else {
        console.log("‚ùå ERRO: Campo is_locked n√£o encontrado - contrato pode n√£o estar atualizado!")
      }

      // Verificar PDAs necess√°rias para integra√ß√£o
      console.log("\nüîë PDAS PARA INTEGRA√á√ÉO:")

      // PDA para vault de SOL
      const [programSolVault, programSolVaultBump] =
        PublicKey.findProgramAddressSync(
          [Buffer.from("program_sol_vault")],
          PROGRAM_ID
        )
      console.log(
        "üí∞ PDA do Vault de SOL: " +
          programSolVault.toString() +
          " (Bump: " +
          programSolVaultBump +
          ")"
      )

      // Gravar todas as informa√ß√µes importantes em um arquivo de configura√ß√£o
      const configData = {
        programId: PROGRAM_ID.toString(),
        stateAddress: stateKeypair.publicKey.toString(),
        statePrivateKey: Array.from(stateKeypair.secretKey),
        programSolVault: programSolVault.toString(),
        programSolVaultBump,
        ownerWallet: walletKeypair.publicKey.toString(),
        multisigTreasury: MULTISIG_TREASURY.toString(),
        // Informa√ß√µes da vers√£o sem mint
        version: "no-mint-swap-only",
        hasReentrancyProtection: stateInfo.isLocked !== undefined,
        contractVersion: "swap-only-v1.0",
      }

      // Criar diret√≥rio para o arquivo de configura√ß√£o se n√£o existir
      const configDir = path.dirname(configOutputPath)
      if (!fs.existsSync(configDir)) {
        fs.mkdirSync(configDir, { recursive: true })
      }

      fs.writeFileSync(
        configOutputPath,
        JSON.stringify(configData, null, 2)
      )
      console.log(`\nüíæ Configura√ß√£o salva em ${configOutputPath}`)

      console.log(
        "\n‚ö†Ô∏è IMPORTANTE: GUARDE ESTES ENDERE√áOS PARA USO FUTURO!"
      )
      console.log("üîë ENDERE√áO DO PROGRAMA: " + PROGRAM_ID.toString())
      console.log(
        "üîë ESTADO DO PROGRAMA: " + stateKeypair.publicKey.toString()
      )
      console.log(
        "üîë OWNER DO PROGRAMA: " + walletKeypair.publicKey.toString()
      )
      console.log(
        "üè¶ MULTISIG TREASURY: " + MULTISIG_TREASURY.toString()
      )
      console.log("üîë PDA SOL VAULT: " + programSolVault.toString())

      // Informa√ß√µes sobre a nova vers√£o
      console.log("\nüîÑ RECURSOS DA VERS√ÉO SEM MINT:")
      console.log("‚úÖ Slot 1: Swap WSOL -> DONUT")
      console.log("‚úÖ Slot 2: Reserva SOL para referrer")
      console.log("‚úÖ Slot 3: Paga SOL ao referrer")
      console.log("‚úÖ Base User: Swap direto WSOL -> DONUT")
      console.log("‚ùå Sistema de mint removido")
      console.log("‚ùå C√°lculo de tokens removido")
      console.log("‚úÖ Prote√ß√£o contra reentrancy mantida")

    } catch (error) {
      console.error(
        "‚ùå ERRO AO INICIALIZAR O ESTADO DA MATRIZ:",
        error
      )

      // Exibir detalhes do erro para diagn√≥stico
      if (error.logs) {
        console.log("\nüìã LOGS DE ERRO:")
        error.logs.forEach((log, i) => console.log(`${i}: ${log}`))
      }
    }
  } catch (error) {
    console.error("‚ùå ERRO GERAL DURANTE O PROCESSO:", error)
  } finally {
    process.exit(0)
  }
}

main()